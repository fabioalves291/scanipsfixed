import re
import sys
import subprocess

def extract_fixed_ips(file_path):
    fixed_ips = {}
    with open(file_path, 'r') as file:
        lines = file.readlines()
        for line in lines:
            match = re.search(r'host\s+(\S+)\s*{', line)
            if match:
                network_name = match.group(1)
            else:
                match = re.search(r'fixed-address\s+(\S+);', line)
                if match and network_name:
                    ip_address = match.group(1)
                    fixed_ips[ip_address] = network_name
                    network_name = None
    # Ordenar os IPs por ordem alfabética dos nomes das redes
    fixed_ips = dict(sorted(fixed_ips.items(), key=lambda item: item[1]))
    return fixed_ips

def group_ips_by_network(ip_list):
    grouped_ips = {}
    for ip, network_name in ip_list:
        if network_name not in grouped_ips:
            grouped_ips[network_name] = []
        grouped_ips[network_name].append(ip)
    return grouped_ips

def find_gaps(ip_list):
    ip_ranges = []
    grouped_ips = group_ips_by_network(ip_list)
    networks = sorted(grouped_ips.keys(), reverse=True)  # Ordena as redes em ordem decrescente
    for network_name in networks:
        ips = sorted(grouped_ips[network_name])  # Ordena os IPs dentro de cada rede
        current_range_start = current_range_end = ips[0]
        for ip in ips[1:]:
            ip_octet = int(ip.split('.')[-1]) # Último octeto do endereço IP
            current_octet = int(current_range_end.split('.')[-1]) # Último octeto do endereço IP atual
            if ip_octet != current_octet + 1:
                ip_ranges.append((current_range_start, current_range_end))
                current_range_start = current_range_end = ip
            else:
                current_range_end = ip
        ip_ranges.append((current_range_start, current_range_end))
    return ip_ranges

def main():
    file_path = 'dhcpd.conf'  # Caminho para o arquivo dhcpd.conf
    
    # Verifica se o Python 2 está presente e tenta executar o script com Python 3
    if sys.version_info.major == 2:
        try:
            subprocess.check_call(['python3', __file__])
        except subprocess.CalledProcessError:
            print("Não foi possível encontrar o Python 3.")
            sys.exit(1)
        sys.exit(0)
    
    fixed_ips = extract_fixed_ips(file_path)
    
    # Filtrar endereços IP inválidos
    valid_ips = []
    for ip, network_name in fixed_ips.items():
        try:
            # Verificar se o endereço IP está no formato correto
            parts = ip.split('.')
            if len(parts) == 4 and all(0 <= int(part) <= 255 for part in parts):
                valid_ips.append((ip, network_name))
        except ValueError:
            # Ignorar se o endereço IP não estiver no formato correto
            pass
    
    # Encontrar lacunas nos intervalos de endereços IP
    ip_ranges = find_gaps(valid_ips)
    
    print("Endereços IP registrados:")
    print("=" * 40)
    print(f"{'Nome da Rede':<20}{'Endereço IP':<20}")
    print("=" * 40)
    for ip, network_name in valid_ips:
        print(f"{network_name:<20}{ip:<20}")
    print("=" * 40)

    print("\nIntervalos de IP disponíveis por rede:")
    print("=" * 40)
    for index, ip_range in enumerate(ip_ranges, start=1):
        print(f"Rede {index}:")
        print("=" * 20)
        print(f"{'De':<15}{'Para':<15}")
        print("=" * 20)
        print(f"{ip_range[0]:<15}{ip_range[1]:<15}")
        print("=" * 20)
    print("=" * 40)

if __name__ == "__main__":
    main()

